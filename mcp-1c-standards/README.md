# MCP 1C Standards (Go)

MCP-сервер со справочником стандартов разработки 1С (BSL): документирующие комментарии, разделы v8std/EDT, проверка комментариев.

Подробная документация: **[docs/](docs/)** — описание сервиса и [инструкция по добавлению стандартов](docs/adding-standards.md).

## Требования

- **Go 1.23+**

## Сборка

```bash
go build -o mcp-1c-standards .
```

Исполняемый файл: `mcp-1c-standards` (или `mcp-1c-standards.exe` на Windows).

## Запуск

Сервер работает в режиме **stdio** (по умолчанию): обмен с клиентом через stdin/stdout.

```bash
./mcp-1c-standards
```

Подключение из Cursor/IDE: укажите команду и аргументы в настройках MCP (см. ниже).

## Инструменты (Tools)

| Инструмент | Описание |
|------------|----------|
| **standards_doc_comment** | Правила и пример оформления документирующего комментария к процедуре/функции 1С (BSL) по v8std и EDT. Опционально: `topic` (параметры, пример, структура). |
| **standards_lookup** | Поиск по разделам стандартов: краткое описание и ссылка. `topic` — id раздела (453, 641, doc-comment, naming, formatting) или ключевое слово; для диагностик BSL LS — код (MissingSpace, FunctionOutParameter, LineLength). |
| **standards_check_comment** | Проверка текста документирующего комментария на соответствие стандарту: наличие «Параметры:», формат строк параметров «Имя - Тип - Описание». |

## Подключение в Cursor

В настройках MCP (например, `~/.cursor/mcp.json` или через UI) добавьте сервер:

```json
{
  "mcpServers": {
    "1c-standards": {
      "command": "/absolute/path/to/mcp-1c-standards"
    }
  }
}
```

Пример с путём внутри проекта:

```json
{
  "mcpServers": {
    "1c-standards": {
      "command": "/home/ser/CursorTest/mcp-1c-standards/mcp-1c-standards"
    }
  }
}
```

После перезапуска Cursor станут доступны инструменты `standards_doc_comment`, `standards_lookup`, `standards_check_comment` — их можно вызывать из чата или агента для быстрой справки по стандартам 1С.

## Контент: только в проекте, без выхода в сеть

Сервис **не обращается к интернету** — все данные берутся из локальных файлов проекта.

Единый каталог контента в проекте: **`internal/tools/content/`** (он же встраивается в бинарник при сборке).

- `internal/tools/content/doc-comment.md` — правила и примеры документирующего комментария (v8std 453, EDT).
- `internal/tools/content/lookup.json` — разделы стандартов (453, 641, doc-comment, naming, formatting) и коды диагностик BSL LS.
- **`internal/tools/content/std-*.md`** — полные тексты стандартов (скачаны с v8std.ru). Сейчас **24 стандарта** с полным текстом, в том числе:
  - **Соглашения при написании кода (31)**: 453, 454, 455, 456 (описание и оформление процедур/модулей), 640 (параметры), 641 (структуры в параметрах), 647 (имена), 544, 547, 686 (ограничения и оператор Перейти, параметр Отказ), 693 (объекты Структура);
  - **Реализация обработки данных (26)**: 437, 438, 657, 726, 783, 791;
  - **Создание и изменение объектов метаданных (1)**: 467, 643, 798;
  - **Общие вопросы безопасности (36)**: 669, 678, 794;
  - **Проектирование интерфейсов 8.3 (7)**: 727 (размеры экрана).

При вызове **standards_lookup** с `topic: <id>` (например 453, 647, 783) сервис подставляет полный текст стандарта из файла `std-<id>.md` (сеть не используется).

### Обновление стандартов (скачать заново)

Скрипт `scripts/fetch_standards.py` берёт **полный список** стандартов из [содержания ИТС](https://its.1c.ru/db/v8std#browse:13:-1) (все подразделы: 1, 26, 31, 35, 36, 38, 39, 40, 7, 11, 15, 23) и скачивает доступные страницы с v8std.ru:

```bash
python3 scripts/fetch_standards.py
```

Без аргументов скачиваются все ID из списка; можно передать отдельные номера: `python3 scripts/fetch_standards.py 453 641 437`. На v8std.ru есть не все стандарты (часть отдаёт 404). Скрипт сохраняет файлы в `internal/tools/content/`. После изменений выполните `go build`, чтобы обновить встроенный контент в бинарнике.

Откуда читается контент (по порядку):

1. Переменная окружения **`MCP_1C_STANDARDS_CONTENT`** — путь к каталогу с `doc-comment.md` и `lookup.json`.
2. Каталог **`content/`** рядом с исполняемым файлом (например при распространении бинарника).
3. Каталог **`content/`** в текущей рабочей директории.
4. Каталог **`internal/tools/content/`** в текущей рабочей директории (при запуске из корня репозитория).
5. Если каталог не найден — используется встроенный в бинарник контент (embed).

Редактируйте файлы в `internal/tools/content/` — при запуске из репозитория сервис подхватит изменения; для бинарника пересоберите проект.

## Лицензия

MIT.
